# Тестовое задание: Backend Developer (Go + PostgreSQL)

## Цель задания

Проверить, как кандидат проектирует и реализует финансово-критичный backend-флоу:
- корректность бизнес-логики;
- консистентность данных при конкурентных запросах;
- безопасность API;
- качество инженерных решений и аргументации.

## Контекст

Есть упрощенный продукт с пользовательскими балансами.  
Нужно реализовать API для создания заявки на вывод средств.

## Что нужно сделать

Реализовать backend-сервис на Go с PostgreSQL, который поддерживает сценарий:
1. Пользователь создает заявку на вывод.
2. Сервис валидирует запрос и проверяет доступный баланс.
3. Сервис резервирует сумму (hold), чтобы исключить двойное списание.
4. Создается запись о выводе со статусом `pending`.
5. Повторный идентичный запрос должен обрабатываться идемпотентно.

## Функциональные требования

### 1) API

Реализовать 3 endpoint:
- `POST /v1/withdrawals`
- `GET /v1/withdrawals/{id}`
- `POST /v1/withdrawals/{id}/confirm`

### 2) Create withdrawal

`POST /v1/withdrawals` принимает:
- `user_id` (uuid/string);
- `amount` (decimal, > 0);
- `currency` (`USDT`);
- `destination` (строка);
- `idempotency_key` (строка, обязательна).

Ожидаемое поведение:
- если `amount <= 0` -> `400`;
- если не хватает доступного баланса -> `409`;
- если `idempotency_key` уже был использован с тем же payload -> вернуть исходный результат (`200/201`, без дубля);
- если `idempotency_key` совпал, но payload отличается -> `422`;
- при успехе создать вывод со статусом `pending` и зарезервировать сумму.

### 3) Confirm withdrawal

`POST /v1/withdrawals/{id}/confirm`:
- переводит `pending -> completed`;
- финально списывает зарезервированную сумму;
- повторный confirm не должен ломать состояние (идемпотентное поведение).

### 4) Read withdrawal

`GET /v1/withdrawals/{id}` возвращает:
- id, user_id, amount, currency, destination;
- статус (`pending`, `completed`, `failed`);
- `created_at`, `updated_at`.

## Нефункциональные требования

### Консистентность

- Исключить двойное списание при конкурентных `POST /withdrawals`.
- Использовать транзакции PostgreSQL там, где это необходимо.
- Явно описать выбранную стратегию (`SELECT ... FOR UPDATE`, уровень изоляции, уникальные ограничения, и т.д.).

### Безопасность

- Добавить простую auth-проверку (например, Bearer token с фиксированным токеном из env, этого достаточно).
- Не раскрывать внутренние детали ошибок в ответах API.
- Базовая валидация входных данных обязательна.

### Наблюдаемость

- Логировать ключевые события: create/confirm/fail (структурировано, в любом удобном формате).

## Минимальная схема БД

Можно изменить по своему усмотрению, но ожидаются сущности:
- `accounts` (баланс и/или доступный + hold);
- `withdrawals`;
- `idempotency_keys` (или эквивалентная реализация);
- `ledger_entries` (опционально, но будет плюсом).

## Технические ограничения

- Go 1.22+;
- PostgreSQL 14+;
- REST API;
- Docker Compose для локального запуска;
- Никаких внешних платёжных интеграций: всё in-memory/mock в рамках сервиса.

## Что нужно сдать

1. Исходный код сервиса.
2. `README.md` с разделами:
- как запустить;
- ключевые решения;
- как обеспечивается консистентность и идемпотентность;
- какие риски остались и как бы вы их закрывали в production.
3. SQL-миграции.
4. Набор тестов.

## Тесты (минимум)

- unit-тесты бизнес-логики;
- интеграционные тесты с PostgreSQL для create/confirm;
- минимум 1 тест на конкурентный сценарий (два параллельных вывода на один баланс).

## Объем и время

- Ориентир: 4-6 часов.
- Не требуется production-ready полнота; важна корректная архитектурная основа и ясная аргументация решений.

## Что можно упростить

- Только одна валюта (`USDT`);
- без реальной blockchain-интеграции;
- без сложного антифрода (достаточно 1-2 простых бизнес-правил, если хотите показать подход).
